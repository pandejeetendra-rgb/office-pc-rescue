<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Office PC Rescue ‚Äî Simple (Graphic Rich)</title>
<style>
  :root{
    --bg1:#050816;
    --bg2:#0b1a3a;
    --panel: rgba(255,255,255,.08);
    --line: rgba(255,255,255,.12);
    --text:#eaf0ff;
    --muted:#a9b6d6;

    --blue:#4aa3ff;
    --green:#3ddc97;
    --amber:#ffcc66;
    --red:#ff5c6c;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    color:var(--text);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:
      radial-gradient(1200px 760px at 16% 12%, rgba(74,163,255,.18), transparent 55%),
      radial-gradient(900px 620px at 80% 18%, rgba(61,220,151,.12), transparent 60%),
      radial-gradient(900px 600px at 72% 88%, rgba(255,92,108,.10), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
    overflow:hidden;
  }
  .wrap{
    height:100%;
    display:grid;
    grid-template-columns: 1.25fr .75fr;
    gap:14px;
    padding:14px;
    max-width: 1280px;
    margin: 0 auto;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns:1fr; grid-template-rows: 1.2fr .8fr; overflow:auto}
    body{overflow:auto}
  }
  .card{
    border:1px solid var(--line);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
    box-shadow: 0 18px 52px rgba(0,0,0,.48);
    overflow:hidden;
    position:relative;
  }
  .head{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    background: rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  }
  .head .t{font-weight:900;font-size:13px}
  .head .s{color:var(--muted);font-size:12px}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:7px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.05);
    color:var(--muted);
    font-size:12px;
    white-space:nowrap;
  }
  .chip b{color:var(--text)}
  .btn{
    border-radius:14px;
    padding:10px 12px;
    border:1px solid var(--line);
    background: rgba(74,163,255,.14);
    color:var(--text);
    font-weight:900;
    cursor:pointer;
  }
  .btn:hover{border-color: rgba(74,163,255,.40)}
  .btn.ghost{background: rgba(255,255,255,.04)}
  .game{
    position:relative;
    height:100%;
    min-height: 520px;
    background: radial-gradient(900px 540px at 40% 20%, rgba(255,255,255,.04), rgba(0,0,0,.16));
  }
  canvas{width:100%;height:100%;display:block}

  /* Right panel (MCQ) */
  .sideBody{padding:14px;display:flex;flex-direction:column;gap:12px}
  .status{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .status .row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .status .big{font-weight:950;font-size:13px}
  .status .small{color:var(--muted);font-size:12px;margin-top:6px;line-height:1.45}
  .progress{
    margin-top:10px;
    height:10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.08);
    overflow:hidden;
  }
  .progress i{
    display:block;height:100%;width:0%;
    background: rgba(61,220,151,.85);
    transition: width .45s ease;
  }

  .qbox{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .q{
    font-weight:950;
    font-size:13px;
    line-height:1.45;
  }
  .opts{display:grid;gap:10px;margin-top:12px}
  .opt{
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:10px 12px;
    cursor:pointer;
    display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
    transition: transform .12s ease, border-color .18s ease;
  }
  .opt:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.20)}
  .opt[disabled]{opacity:.55;cursor:not-allowed}
  .left{display:flex;gap:10px;align-items:flex-start}
  .badge{
    width:28px;height:28px;border-radius:10px;
    border:1px solid rgba(74,163,255,.22);
    background: rgba(74,163,255,.12);
    display:grid;place-items:center;
    flex:0 0 auto;
  }
  .kbd{
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.28);
    color:var(--muted);
    font-size:11px;
    white-space:nowrap;
  }
  .fb{
    display:none;
    margin-top:12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .fb.show{display:block}
  .fb.good{border-color: rgba(61,220,151,.25); background: linear-gradient(180deg, rgba(61,220,151,.10), rgba(0,0,0,.22))}
  .fb.bad{border-color: rgba(255,92,108,.25); background: linear-gradient(180deg, rgba(255,92,108,.10), rgba(0,0,0,.22))}
  .fb .t{font-weight:950}
  .fb .p{margin-top:6px;color:var(--muted);font-size:12.5px;line-height:1.45}
  .rowBtns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}

  .hint{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    padding:12px;
    color:var(--muted);
    font-size:12.5px;
    line-height:1.45;
  }
</style>
</head>
<body>
<div class="wrap">

  <!-- GAME -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Office PC Rescue (Simple Game)</div>
        <div class="s">Answer one question per checkpoint. Correct builds the shield path and moves you forward.</div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <div class="chip">Checkpoint: <b id="cpName">Accounts</b></div>
        <button class="btn ghost" id="resetBtn" type="button">Reset</button>
      </div>
    </div>
    <div class="game">
      <canvas id="cv"></canvas>
    </div>
  </div>

  <!-- MCQ PANEL -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Decision Panel</div>
        <div class="s">Options shuffle every time (no ‚Äúalways A‚Äù).</div>
      </div>
      <div class="chip">Progress <b id="progText">0/5</b></div>
    </div>

    <div class="sideBody">
      <div class="status">
        <div class="row">
          <div class="big">Security Path</div>
          <div class="chip">Rescue status: <b id="rescueText">In progress</b></div>
        </div>
        <div class="small" id="statusText">Secure the PC by completing all 5 checkpoints.</div>
        <div class="progress" aria-hidden="true"><i id="bar"></i></div>
      </div>

      <div class="qbox">
        <div class="q" id="qText">Loading‚Ä¶</div>
        <div class="opts" id="opts"></div>

        <div class="fb" id="fb">
          <div class="t" id="fbT">‚Äî</div>
          <div class="p" id="fbP">‚Äî</div>
          <div class="rowBtns">
            <button class="btn" id="nextBtn" type="button">Next checkpoint</button>
            <button class="btn ghost" id="retryBtn" type="button">Try again</button>
          </div>
        </div>
      </div>

      <div class="hint">
        Visuals are intentionally ‚ÄúWindows-like‚Äù but not a clone. Replace the question bank with your chapter questions anytime.
      </div>
    </div>
  </div>

</div>

<script>
/* =========================================================
   Simple Office PC Rescue
   - 5 checkpoints
   - 1 question each
   - Correct: checkpoint turns green + animated shield bridge + player walks
   - Wrong: alert flash + shake + retry
   - Options always shuffled
========================================================= */

const CHECKPOINTS = [
  { key:"accounts", label:"Accounts", icon:"üë§" },
  { key:"lock",     label:"Screen Lock", icon:"üîí" },
  { key:"updates",  label:"Updates", icon:"üîÑ" },
  { key:"firewall", label:"Firewall", icon:"üõ°Ô∏è" },
  { key:"privacy",  label:"Privacy", icon:"üëÅÔ∏è" },
];

// Replace these with your chapter-derived questions later.
const QUESTIONS = {
  accounts: {
    q: "Best practice for daily work on an office PC?",
    options: [
      "Use a standard user account and elevate only when required",
      "Always use Administrator for convenience",
      "Share one admin account with the team",
      "Disable sign-in methods to avoid prompts"
    ],
    correct: 0,
    ok: "Least privilege reduces damage if something goes wrong.",
    bad:"Admin-by-default increases risk and impact."
  },
  lock: {
    q: "What does auto-lock primarily prevent?",
    options: [
      "Walk-up access when the user leaves the desk",
      "Low disk space",
      "Slow internet speed",
      "Printer driver issues"
    ],
    correct: 0,
    ok: "Auto-lock protects shared spaces and busy offices.",
    bad:"Auto-lock is a security control, not a performance tool."
  },
  updates: {
    q: "Why are Windows updates important for security?",
    options: [
      "They patch known vulnerabilities attackers exploit",
      "They remove the need for backups",
      "They guarantee no phishing will happen",
      "They only change themes and wallpapers"
    ],
    correct: 0,
    ok: "Updates close known security holes.",
    bad:"Updates help, but they are not the only protection you need."
  },
  firewall: {
    q: "Which profile should be strictest on untrusted networks?",
    options: [
      "Public profile",
      "Private profile",
      "Domain profile only",
      "No profile needs strict rules"
    ],
    correct: 0,
    ok: "Public networks are riskier, so rules should be stricter.",
    bad:"Public networks are typically less trustworthy."
  },
  privacy: {
    q: "Good rule for app permissions (camera/mic/location)?",
    options: [
      "Allow only when needed (least privilege)",
      "Allow everything once and forget",
      "Permissions do not affect security",
      "Always allow microphone for all apps"
    ],
    correct: 0,
    ok: "Grant only what is necessary to reduce exposure.",
    bad:"Over-permissioning increases data leakage risk."
  }
};

const el = {
  cv: document.getElementById("cv"),
  cpName: document.getElementById("cpName"),
  progText: document.getElementById("progText"),
  rescueText: document.getElementById("rescueText"),
  statusText: document.getElementById("statusText"),
  bar: document.getElementById("bar"),
  qText: document.getElementById("qText"),
  opts: document.getElementById("opts"),
  fb: document.getElementById("fb"),
  fbT: document.getElementById("fbT"),
  fbP: document.getElementById("fbP"),
  nextBtn: document.getElementById("nextBtn"),
  retryBtn: document.getElementById("retryBtn"),
  resetBtn: document.getElementById("resetBtn"),
};

function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

/* ---------- Game state ---------- */
const state = {
  idx: 0,
  solved: Array(CHECKPOINTS.length).fill(false),
  locked: false,
  currentQ: null,
  // animation
  playerX: 0,
  playerY: 0,
  targetX: 0,
  moving: false,
  moveT: 0,
  flash: 0,
  shake: 0,
  particles: [],
  bridges: 0, // how many segments built (0..4)
};

function reset(){
  state.idx = 0;
  state.solved.fill(false);
  state.locked = false;
  state.flash = 0;
  state.shake = 0;
  state.particles.length = 0;
  state.bridges = 0;

  // player starts at first checkpoint position (computed after resize)
  resize();
  state.playerX = pathPts[0].x;
  state.playerY = pathPts[0].y + 18;
  state.targetX = state.playerX;
  state.moving = false;
  state.moveT = 0;

  el.rescueText.textContent = "In progress";
  el.statusText.textContent = "Secure the PC by completing all 5 checkpoints.";
  el.fb.className = "fb";
  loadQuestion();
  updateUI();
}

function updateUI(){
  const done = state.solved.filter(Boolean).length;
  el.progText.textContent = `${done}/${CHECKPOINTS.length}`;
  el.bar.style.width = `${(done/CHECKPOINTS.length)*100}%`;
  el.cpName.textContent = CHECKPOINTS[state.idx]?.label || "Completed";

  if(done === CHECKPOINTS.length){
    el.rescueText.textContent = "Rescued";
    el.statusText.textContent = "All checkpoints secured. PC is safe for work.";
  }
}

/* ---------- Questions ---------- */
function loadQuestion(){
  const cp = CHECKPOINTS[state.idx];
  if(!cp){
    // finished
    el.qText.textContent = "‚úÖ PC Rescued! All security checkpoints are secured.";
    el.opts.innerHTML = "";
    el.fb.className = "fb show good";
    el.fbT.textContent = "Mission complete";
    el.fbP.textContent = "Well done. You restored baseline Windows security settings.";
    el.nextBtn.style.display = "none";
    el.retryBtn.textContent = "Play again";
    return;
  }

  // Shuffle options and recompute correct index
  const q = QUESTIONS[cp.key];
  const opts = q.options.map((t,i)=> ({t, orig:i}));
  const sh = shuffle(opts);
  const newCorrect = sh.findIndex(o => o.orig === q.correct);
  state.currentQ = {
    q: q.q,
    options: sh.map(o=>o.t),
    correct: newCorrect,
    ok: q.ok,
    bad: q.bad
  };

  el.qText.textContent = `(${cp.icon} ${cp.label}) ${state.currentQ.q}`;
  el.opts.innerHTML = "";
  el.fb.className = "fb";
  el.nextBtn.style.display = "inline-block";
  el.retryBtn.textContent = "Try again";

  const badges = ["A","B","C","D"];
  state.currentQ.options.forEach((t,i)=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "opt";
    b.innerHTML = `
      <div class="left">
        <div class="badge">${badges[i] || "‚Ä¢"}</div>
        <div style="font-weight:850;line-height:1.35">${t}</div>
      </div>
      <div class="kbd">${i+1}</div>
    `;
    b.addEventListener("click", ()=> answer(i));
    el.opts.appendChild(b);
  });

  state.locked = false;
}

/* ---------- Answer handling ---------- */
function lockOptions(v){
  [...el.opts.querySelectorAll("button")].forEach(x=> x.disabled = v);
}

function confetti(x,y,good=true){
  const n = good ? 26 : 18;
  for(let i=0;i<n;i++){
    state.particles.push({
      x,y,
      vx:(Math.random()*2-1) * (good ? 2.6 : 2.1),
      vy:(Math.random()*-2.6) - (good ? 2.6 : 2.2),
      life: good ? 48 : 38,
      good
    });
  }
}

function answer(i){
  if(state.locked) return;
  state.locked = true;
  lockOptions(true);

  const ok = (i === state.currentQ.correct);

  if(ok){
    el.fb.className = "fb show good";
    el.fbT.textContent = "Correct";
    el.fbP.textContent = state.currentQ.ok;

    // mark solved + build next bridge + move player
    state.solved[state.idx] = true;
    state.bridges = Math.max(state.bridges, state.idx); // segments built from 0..idx-1, so idx solved builds segment idx
    confetti(pathPts[state.idx].x, pathPts[state.idx].y, true);

    // move to next checkpoint (if exists)
    const nextIdx = state.idx + 1;
    if(nextIdx < CHECKPOINTS.length){
      startMove(nextIdx);
    }else{
      // last solved -> finish
      state.idx++;
      loadQuestion();
    }

  }else{
    el.fb.className = "fb show bad";
    el.fbT.textContent = "Not correct";
    el.fbP.textContent = state.currentQ.bad;

    // alert flash + shake + red particles
    state.flash = 1.0;
    state.shake = 1.0;
    confetti(pathPts[state.idx].x, pathPts[state.idx].y, false);
  }

  updateUI();
}

/* ---------- Next / Retry ---------- */
el.nextBtn.addEventListener("click", ()=>{
  // If not solved, force retry
  if(!state.solved[state.idx]){
    // keep same checkpoint, reshuffle and try again
    loadQuestion();
    return;
  }
  // If solved but still on same idx, question will update after movement
  // This button mostly helps mobile users, but we keep it.
});

el.retryBtn.addEventListener("click", ()=>{
  if(el.retryBtn.textContent === "Play again"){
    reset();
    return;
  }
  loadQuestion();
});

el.resetBtn.addEventListener("click", reset);

/* ---------- Movement ---------- */
let pathPts = [];
function startMove(nextIdx){
  state.moving = true;
  state.moveT = 0;
  state.targetX = pathPts[nextIdx].x;
  state.targetY = pathPts[nextIdx].y + 18;
  state.nextIdx = nextIdx;
}

function ease(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

/* ---------- Canvas rendering ---------- */
const ctx = el.cv.getContext("2d", {alpha:false});
let W=0,H=0, dpr=1;

function resize(){
  const r = el.cv.getBoundingClientRect();
  dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(r.width*dpr);
  H = Math.floor(r.height*dpr);
  el.cv.width = W;
  el.cv.height = H;

  // define path points (corridor checkpoints)
  const padX = 70*dpr;
  const y = Math.floor(H*0.55);
  const span = (W - padX*2) / (CHECKPOINTS.length-1);
  pathPts = CHECKPOINTS.map((_,i)=> ({
    x: Math.floor(padX + span*i),
    y: y
  }));

  // place player if uninitialized
  if(!state.playerX){
    state.playerX = pathPts[0].x;
    state.playerY = pathPts[0].y + 18;
  }
}
window.addEventListener("resize", resize);

/* Draw helpers */
function roundRect(x,y,w,h,r){
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function glowCircle(x,y,rad,alpha){
  ctx.save();
  ctx.globalAlpha = alpha;
  const g = ctx.createRadialGradient(x,y,0,x,y,rad);
  g.addColorStop(0,"rgba(74,163,255,.55)");
  g.addColorStop(1,"rgba(74,163,255,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawBackground(){
  // base
  ctx.fillStyle = "#071024";
  ctx.fillRect(0,0,W,H);

  // soft blobs
  const g1 = ctx.createRadialGradient(W*0.22,H*0.18,0,W*0.22,H*0.18,W*0.62);
  g1.addColorStop(0,"rgba(74,163,255,.18)");
  g1.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g1; ctx.fillRect(0,0,W,H);

  const g2 = ctx.createRadialGradient(W*0.82,H*0.78,0,W*0.82,H*0.78,W*0.70);
  g2.addColorStop(0,"rgba(61,220,151,.10)");
  g2.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g2; ctx.fillRect(0,0,W,H);

  // corridor floor
  const floorY = Math.floor(H*0.62);
  const fg = ctx.createLinearGradient(0,floorY,0,H);
  fg.addColorStop(0,"rgba(255,255,255,.06)");
  fg.addColorStop(1,"rgba(0,0,0,.35)");
  ctx.fillStyle = fg;
  ctx.fillRect(0,floorY,W,H-floorY);

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  const step = 38*dpr;
  for(let x=0;x<W;x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0;y<H;y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();

  // "window" panels
  for(let i=0;i<3;i++){
    const x = (W*(0.12 + i*0.28));
    const y = H*0.18;
    const w = W*0.18;
    const h = H*0.18;
    ctx.save();
    ctx.globalAlpha = 0.55;
    roundRect(x,y,w,h,18*dpr);
    ctx.fillStyle = "rgba(255,255,255,.05)";
    ctx.fill();
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 2*dpr;
    ctx.stroke();
    ctx.restore();
  }

  // taskbar
  const tbH = 64*dpr;
  const tbY = H - tbH - 18*dpr;
  ctx.save();
  roundRect(18*dpr,tbY,W-36*dpr,tbH,18*dpr);
  ctx.fillStyle = "rgba(0,0,0,.30)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 2*dpr;
  ctx.stroke();
  // icons
  for(let i=0;i<4;i++){
    const ix = 36*dpr + i*52*dpr;
    const iy = tbY + 16*dpr;
    roundRect(ix,iy,36*dpr,36*dpr,12*dpr);
    ctx.fillStyle = "rgba(255,255,255,.05)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.12)"; ctx.stroke();
  }
  ctx.restore();
}

function drawPath(){
  // base line
  ctx.save();
  ctx.lineWidth = 6*dpr;
  ctx.lineCap = "round";
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.beginPath();
  ctx.moveTo(pathPts[0].x, pathPts[0].y);
  for(let i=1;i<pathPts.length;i++) ctx.lineTo(pathPts[i].x, pathPts[i].y);
  ctx.stroke();

  // built "shield bridge" segments
  for(let i=0;i<state.bridges;i++){
    const a = pathPts[i], b = pathPts[i+1];
    const grad = ctx.createLinearGradient(a.x,a.y,b.x,b.y);
    grad.addColorStop(0,"rgba(61,220,151,.55)");
    grad.addColorStop(1,"rgba(74,163,255,.20)");
    ctx.strokeStyle = grad;
    ctx.lineWidth = 10*dpr;
    ctx.beginPath();
    ctx.moveTo(a.x,a.y);
    ctx.lineTo(b.x,b.y);
    ctx.stroke();

    // little pulses
    glowCircle(b.x,b.y,38*dpr,0.20);
  }
  ctx.restore();
}

function drawCheckpoints(){
  for(let i=0;i<pathPts.length;i++){
    const p = pathPts[i];
    const solved = state.solved[i];
    const isCurrent = (i === state.idx);

    // glow
    if(isCurrent) glowCircle(p.x,p.y,70*dpr,0.30);

    // outer ring
    ctx.save();
    ctx.lineWidth = 3*dpr;
    ctx.strokeStyle = solved ? "rgba(61,220,151,.85)" : (isCurrent ? "rgba(74,163,255,.85)" : "rgba(255,255,255,.25)");
    ctx.fillStyle = "rgba(0,0,0,.28)";
    ctx.beginPath(); ctx.arc(p.x,p.y,22*dpr,0,Math.PI*2); ctx.fill(); ctx.stroke();

    // inner light
    ctx.fillStyle = solved ? "rgba(61,220,151,.95)" : (isCurrent ? "rgba(74,163,255,.85)" : "rgba(255,255,255,.25)");
    ctx.beginPath(); ctx.arc(p.x,p.y,10*dpr,0,Math.PI*2); ctx.fill();

    // label plate
    const label = CHECKPOINTS[i].label;
    const plateW = Math.max(96*dpr, (label.length*7.2)*dpr);
    const plateH = 28*dpr;
    const px = p.x - plateW/2;
    const py = p.y - 56*dpr;
    roundRect(px,py,plateW,plateH,12*dpr);
    ctx.fillStyle = "rgba(0,0,0,.34)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.stroke();

    // text
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, p.x, py + plateH/2);

    // small icon
    ctx.font = `${14*dpr}px system-ui, Segoe UI, Arial`;
    ctx.fillText(CHECKPOINTS[i].icon, p.x, p.y - 86*dpr);

    ctx.restore();
  }
}

function drawPlayer(t){
  // simple character: body + head + toolbag + walking feet
  const x = state.playerX;
  const y = state.playerY;
  const bob = Math.sin(t*8) * (state.moving ? 2*dpr : 1*dpr);

  ctx.save();
  ctx.translate(x, y + bob);

  // shadow
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.beginPath(); ctx.ellipse(0, 18*dpr, 22*dpr, 8*dpr, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // legs (walk)
  const step = Math.sin(t*10) * (state.moving ? 10*dpr : 2*dpr);
  ctx.strokeStyle = "rgba(234,240,255,.75)";
  ctx.lineWidth = 4*dpr;
  ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(-6*dpr, 10*dpr); ctx.lineTo(-10*dpr + step*0.06, 24*dpr); ctx.stroke();
  ctx.beginPath(); ctx.moveTo( 6*dpr, 10*dpr); ctx.lineTo( 10*dpr - step*0.06, 24*dpr); ctx.stroke();

  // body
  roundRect(-14*dpr, -10*dpr, 28*dpr, 26*dpr, 10*dpr);
  ctx.fillStyle = "rgba(74,163,255,.25)";
  ctx.fill();
  ctx.strokeStyle = "rgba(74,163,255,.55)";
  ctx.stroke();

  // toolbag
  roundRect(16*dpr, 0*dpr, 20*dpr, 16*dpr, 7*dpr);
  ctx.fillStyle = "rgba(255,204,102,.18)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,204,102,.55)";
  ctx.stroke();

  // head
  ctx.beginPath(); ctx.arc(0, -18*dpr, 10*dpr, 0, Math.PI*2);
  ctx.fillStyle = "rgba(234,240,255,.85)";
  ctx.fill();

  // visor glow
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = "rgba(61,220,151,.65)";
  roundRect(-7*dpr, -21*dpr, 14*dpr, 6*dpr, 3*dpr);
  ctx.fill();
  ctx.globalAlpha = 1;

  // tiny shield aura when moving
  if(state.moving){
    const g = ctx.createRadialGradient(0,-2*dpr,0,0,-2*dpr,40*dpr);
    g.addColorStop(0,"rgba(61,220,151,.18)");
    g.addColorStop(1,"rgba(61,220,151,0)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(0,-2*dpr,40*dpr,0,Math.PI*2); ctx.fill();
  }

  ctx.restore();
}

function drawParticles(){
  for(const p of state.particles){
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life/60);
    ctx.fillStyle = p.good ? "rgba(61,220,151,.9)" : "rgba(255,92,108,.9)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3*dpr, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

/* ---------- Loop ---------- */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last = now;

  // movement
  if(state.moving){
    state.moveT += dt;
    const t = clamp(state.moveT / 0.85, 0, 1);
    const e = ease(t);
    const sx = pathPts[state.idx].x;
    const sy = pathPts[state.idx].y + 18;
    state.playerX = sx + (state.targetX - sx) * e;
    state.playerY = sy + (state.targetY - sy) * e;

    if(t >= 1){
      state.moving = false;
      state.idx = state.nextIdx;
      loadQuestion();
      updateUI();
    }
  }

  // flash + shake
  state.flash = Math.max(0, state.flash - dt*2.2);
  state.shake = Math.max(0, state.shake - dt*2.6);

  // particles
  for(const p of state.particles){
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vy += 0.22 * 60 * dt;
    p.life -= 1;
  }
  state.particles = state.particles.filter(p=> p.life > 0);

  // render
  ctx.save();
  // shake transform
  if(state.shake > 0){
    const mag = 6*dpr*state.shake;
    ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
  }

  drawBackground();
  drawPath();
  drawCheckpoints();
  drawParticles();
  drawPlayer(now/1000);

  // alert flash overlay
  if(state.flash > 0){
    ctx.save();
    ctx.globalAlpha = 0.22 * state.flash;
    ctx.fillStyle = "rgba(255,92,108,.9)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  ctx.restore();

  requestAnimationFrame(tick);
}

/* ---------- Movement trigger on correct ---------- */
function startMove(nextIdx){
  state.moving = true;
  state.moveT = 0;
  state.targetX = pathPts[nextIdx].x;
  state.targetY = pathPts[nextIdx].y + 18;

  // build bridge segment now (visual reward)
  state.bridges = Math.max(state.bridges, state.idx+1);
}

/* ---------- Keyboard support ---------- */
document.addEventListener("keydown", (e)=>{
  const n = parseInt(e.key,10);
  if(n>=1 && n<=4){
    const btn = el.opts.querySelectorAll("button")[n-1];
    if(btn && !btn.disabled) btn.click();
  }
});

/* ---------- Start ---------- */
resize();
reset();
requestAnimationFrame(tick);
</script>
</body>
</html>
