<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Office PC Rescue ‚Äî Simple Game (Mode 1+2)</title>
<style>
  :root{
    --bg1:#050816;
    --bg2:#0b1a3a;
    --panel: rgba(255,255,255,.08);
    --line: rgba(255,255,255,.12);
    --text:#eaf0ff;
    --muted:#a9b6d6;

    --blue:#4aa3ff;
    --green:#3ddc97;
    --amber:#ffcc66;
    --red:#ff5c6c;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    color:var(--text);
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:
      radial-gradient(1200px 760px at 16% 12%, rgba(74,163,255,.18), transparent 55%),
      radial-gradient(900px 620px at 80% 18%, rgba(61,220,151,.12), transparent 60%),
      radial-gradient(900px 600px at 72% 88%, rgba(255,92,108,.10), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg2));
    overflow:hidden;
  }
  .wrap{
    height:100%;
    display:grid;
    grid-template-columns: 1.28fr .72fr;
    gap:14px;
    padding:14px;
    max-width: 1320px;
    margin: 0 auto;
  }
  @media (max-width: 980px){
    .wrap{grid-template-columns:1fr; grid-template-rows: 1.12fr .88fr; overflow:auto}
    body{overflow:auto}
  }
  .card{
    border:1px solid var(--line);
    border-radius:18px;
    background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
    box-shadow: 0 18px 52px rgba(0,0,0,.48);
    overflow:hidden;
    position:relative;
  }
  .head{
    padding:12px 14px;
    border-bottom:1px solid var(--line);
    background: rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  }
  .head .t{font-weight:900;font-size:13px}
  .head .s{color:var(--muted);font-size:12px}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    padding:7px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.05);
    color:var(--muted);
    font-size:12px;
    white-space:nowrap;
  }
  .chip b{color:var(--text)}
  .btn{
    border-radius:14px;
    padding:10px 12px;
    border:1px solid var(--line);
    background: rgba(74,163,255,.14);
    color:var(--text);
    font-weight:900;
    cursor:pointer;
  }
  .btn:hover{border-color: rgba(74,163,255,.40)}
  .btn.ghost{background: rgba(255,255,255,.04)}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .game{position:relative;height:100%;min-height: 540px;background: radial-gradient(900px 540px at 40% 20%, rgba(255,255,255,.04), rgba(0,0,0,.16));}
  canvas{width:100%;height:100%;display:block}

  .tabs{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .seg{
    display:inline-flex;
    border:1px solid var(--line);
    background: rgba(255,255,255,.04);
    border-radius:999px;
    overflow:hidden;
  }
  .seg button{
    border:0;
    padding:8px 12px;
    background: transparent;
    color: var(--muted);
    font-weight:900;
    cursor:pointer;
  }
  .seg button.active{
    background: rgba(74,163,255,.14);
    color: var(--text);
  }

  .sideBody{padding:14px;display:flex;flex-direction:column;gap:12px}
  .status{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .status .row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .status .big{font-weight:950;font-size:13px}
  .status .small{color:var(--muted);font-size:12px;margin-top:6px;line-height:1.45}
  .progress{
    margin-top:10px;
    height:10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.08);
    overflow:hidden;
  }
  .progress i{
    display:block;height:100%;width:0%;
    background: rgba(61,220,151,.85);
    transition: width .45s ease;
  }

  .qbox{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .q{font-weight:950;font-size:13px;line-height:1.45}
  .opts{display:grid;gap:10px;margin-top:12px}
  .opt{
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:10px 12px;
    cursor:pointer;
    display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
    transition: transform .12s ease, border-color .18s ease;
  }
  .opt:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.20)}
  .opt[disabled]{opacity:.55;cursor:not-allowed}
  .left{display:flex;gap:10px;align-items:flex-start}
  .badge{
    width:28px;height:28px;border-radius:10px;
    border:1px solid rgba(74,163,255,.22);
    background: rgba(74,163,255,.12);
    display:grid;place-items:center;
    flex:0 0 auto;
  }
  .kbd{
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.28);
    color:var(--muted);
    font-size:11px;
    white-space:nowrap;
  }
  .fb{
    display:none;
    margin-top:12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:12px;
  }
  .fb.show{display:block}
  .fb.good{border-color: rgba(61,220,151,.25); background: linear-gradient(180deg, rgba(61,220,151,.10), rgba(0,0,0,.22))}
  .fb.bad{border-color: rgba(255,92,108,.25); background: linear-gradient(180deg, rgba(255,92,108,.10), rgba(0,0,0,.22))}
  .fb .t{font-weight:950}
  .fb .p{margin-top:6px;color:var(--muted);font-size:12.5px;line-height:1.45}
  .rowBtns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}

  .hint{
    border:1px solid var(--line);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    padding:12px;
    color:var(--muted);
    font-size:12.5px;
    line-height:1.45;
  }
</style>
</head>
<body>
<div class="wrap">

  <!-- GAME -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Office PC Rescue (Simple)</div>
        <div class="s" id="sceneSub">Mode 1: Office Corridor with CCTV scan + warning icons</div>
      </div>
      <div class="tabs">
        <div class="seg" role="tablist" aria-label="Mode">
          <button id="modeCorridor" class="active" type="button">Mode 1: Corridor</button>
          <button id="modeDesktop" type="button">Mode 2: Desktop</button>
        </div>
        <div class="chip">Checkpoint: <b id="cpName">Accounts</b></div>
        <button class="btn ghost" id="resetBtn" type="button">Reset</button>
      </div>
    </div>
    <div class="game">
      <canvas id="cv"></canvas>
    </div>
  </div>

  <!-- MCQ PANEL -->
  <div class="card">
    <div class="head">
      <div>
        <div class="t">Decision Panel</div>
        <div class="s">Options shuffle every time.</div>
      </div>
      <div class="chip">Progress <b id="progText">0/5</b></div>
    </div>

    <div class="sideBody">
      <div class="status">
        <div class="row">
          <div class="big">Security Path</div>
          <div class="chip">Status: <b id="rescueText">In progress</b></div>
        </div>
        <div class="small" id="statusText">Secure the PC by completing all 5 checkpoints.</div>
        <div class="progress" aria-hidden="true"><i id="bar"></i></div>
      </div>

      <div class="qbox">
        <div class="q" id="qText">Loading‚Ä¶</div>
        <div class="opts" id="opts"></div>

        <div class="fb" id="fb">
          <div class="t" id="fbT">‚Äî</div>
          <div class="p" id="fbP">‚Äî</div>
          <div class="rowBtns">
            <button class="btn" id="nextBtn" type="button">Next checkpoint</button>
            <button class="btn ghost" id="retryBtn" type="button">Try again</button>
          </div>
        </div>
      </div>

      <div class="hint">
        Mode 1 gives ‚Äúgame feeling‚Äù (CCTV scan + alert icons). Mode 2 shows a ‚Äúdesktop rescue‚Äù UI where fixes visually clean up the desktop.
      </div>
    </div>
  </div>

</div>

<script>
/* =========================================================
   Office PC Rescue ‚Äî Simple + Graphic Rich
   Mode 1: Office Corridor + CCTV scan lines + warning icons
   Mode 2: Desktop Rescue (icons/popups) that get "fixed"
   - 5 checkpoints
   - 1 MCQ each
   - Correct: checkpoint green + bridge build + player moves
   - Wrong: alert flash + shake + retry
   - Options shuffled always
========================================================= */

const CHECKPOINTS = [
  { key:"accounts", label:"Accounts", icon:"üë§" },
  { key:"lock",     label:"Screen Lock", icon:"üîí" },
  { key:"updates",  label:"Updates", icon:"üîÑ" },
  { key:"firewall", label:"Firewall", icon:"üõ°Ô∏è" },
  { key:"privacy",  label:"Privacy", icon:"üëÅÔ∏è" },
];

// Replace later with chapter-derived questions.
const QUESTIONS = {
  accounts: {
    q: "Best practice for daily work on an office PC?",
    options: [
      "Use a standard user account and elevate only when required",
      "Always use Administrator for convenience",
      "Share one admin account with the team",
      "Disable sign-in methods to avoid prompts"
    ],
    correct: 0,
    ok: "Least privilege reduces damage if something goes wrong.",
    bad:"Admin-by-default increases risk and impact."
  },
  lock: {
    q: "What does auto-lock primarily prevent?",
    options: [
      "Walk-up access when the user leaves the desk",
      "Low disk space",
      "Slow internet speed",
      "Printer driver issues"
    ],
    correct: 0,
    ok: "Auto-lock protects shared spaces and busy offices.",
    bad:"Auto-lock is a security control, not a performance tool."
  },
  updates: {
    q: "Why are Windows updates important for security?",
    options: [
      "They patch known vulnerabilities attackers exploit",
      "They remove the need for backups",
      "They guarantee no phishing will happen",
      "They only change themes and wallpapers"
    ],
    correct: 0,
    ok: "Updates close known security holes.",
    bad:"Updates help, but they are not the only protection you need."
  },
  firewall: {
    q: "Which profile should be strictest on untrusted networks?",
    options: [
      "Public profile",
      "Private profile",
      "Domain profile only",
      "No profile needs strict rules"
    ],
    correct: 0,
    ok: "Public networks are riskier, so rules should be stricter.",
    bad:"Public networks are typically less trustworthy."
  },
  privacy: {
    q: "Good rule for app permissions (camera/mic/location)?",
    options: [
      "Allow only when needed (least privilege)",
      "Allow everything once and forget",
      "Permissions do not affect security",
      "Always allow microphone for all apps"
    ],
    correct: 0,
    ok: "Grant only what is necessary to reduce exposure.",
    bad:"Over-permissioning increases data leakage risk."
  }
};

const el = {
  cv: document.getElementById("cv"),
  sceneSub: document.getElementById("sceneSub"),
  cpName: document.getElementById("cpName"),
  progText: document.getElementById("progText"),
  rescueText: document.getElementById("rescueText"),
  statusText: document.getElementById("statusText"),
  bar: document.getElementById("bar"),
  qText: document.getElementById("qText"),
  opts: document.getElementById("opts"),
  fb: document.getElementById("fb"),
  fbT: document.getElementById("fbT"),
  fbP: document.getElementById("fbP"),
  nextBtn: document.getElementById("nextBtn"),
  retryBtn: document.getElementById("retryBtn"),
  resetBtn: document.getElementById("resetBtn"),
  modeCorridor: document.getElementById("modeCorridor"),
  modeDesktop: document.getElementById("modeDesktop"),
};

function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

/* ---------- Game state ---------- */
const state = {
  idx: 0,
  solved: Array(CHECKPOINTS.length).fill(false),
  locked: false,
  currentQ: null,

  // animation
  playerX: 0,
  playerY: 0,
  targetX: 0,
  targetY: 0,
  moving: false,
  moveT: 0,

  flash: 0,
  shake: 0,
  particles: [],
  bridges: 0, // segments built

  // Mode
  mode: "corridor", // "corridor" | "desktop"

  // Corridor scan / warning icons
  scanY: 0,
  warnOrbs: [],

  // Desktop scene items
  desktopIcons: [],
  popups: [],
};

function updateSceneSub(){
  if(state.mode === "corridor"){
    el.sceneSub.textContent = "Mode 1: Office Corridor with CCTV scan + warning icons";
  }else{
    el.sceneSub.textContent = "Mode 2: Desktop Rescue (popups and icons get cleaned up)";
  }
}

function updateUI(){
  const done = state.solved.filter(Boolean).length;
  el.progText.textContent = `${done}/${CHECKPOINTS.length}`;
  el.bar.style.width = `${(done/CHECKPOINTS.length)*100}%`;
  el.cpName.textContent = CHECKPOINTS[state.idx]?.label || "Completed";

  if(done === CHECKPOINTS.length){
    el.rescueText.textContent = "Rescued";
    el.statusText.textContent = "All checkpoints secured. PC is safe for work.";
  }else{
    el.rescueText.textContent = "In progress";
    el.statusText.textContent = "Secure the PC by completing all 5 checkpoints.";
  }
}

function reset(){
  state.idx = 0;
  state.solved.fill(false);
  state.locked = false;

  state.flash = 0;
  state.shake = 0;
  state.particles.length = 0;
  state.bridges = 0;

  resize();
  state.playerX = pathPts[0].x;
  state.playerY = pathPts[0].y + 18;
  state.targetX = state.playerX;
  state.targetY = state.playerY;
  state.moving = false;
  state.moveT = 0;

  state.scanY = 0;
  state.warnOrbs = makeWarnOrbs();

  initDesktopScene(); // rebuild desktop items

  el.fb.className = "fb";
  loadQuestion();
  updateUI();
}

/* ---------- Questions ---------- */
function loadQuestion(){
  const cp = CHECKPOINTS[state.idx];
  if(!cp){
    el.qText.textContent = "‚úÖ PC Rescued! All checkpoints are secured.";
    el.opts.innerHTML = "";
    el.fb.className = "fb show good";
    el.fbT.textContent = "Mission complete";
    el.fbP.textContent = "Well done. You restored baseline Windows security settings.";
    el.nextBtn.style.display = "none";
    el.retryBtn.textContent = "Play again";
    return;
  }

  const q = QUESTIONS[cp.key];
  const opts = q.options.map((t,i)=> ({t, orig:i}));
  const sh = shuffle(opts);
  const newCorrect = sh.findIndex(o => o.orig === q.correct);

  state.currentQ = {
    q: q.q,
    options: sh.map(o=>o.t),
    correct: newCorrect,
    ok: q.ok,
    bad: q.bad
  };

  el.qText.textContent = `(${cp.icon} ${cp.label}) ${state.currentQ.q}`;
  el.opts.innerHTML = "";
  el.fb.className = "fb";
  el.nextBtn.style.display = "inline-block";
  el.retryBtn.textContent = "Try again";

  const badges = ["A","B","C","D"];
  state.currentQ.options.forEach((t,i)=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "opt";
    b.innerHTML = `
      <div class="left">
        <div class="badge">${badges[i] || "‚Ä¢"}</div>
        <div style="font-weight:850;line-height:1.35">${t}</div>
      </div>
      <div class="kbd">${i+1}</div>
    `;
    b.addEventListener("click", ()=> answer(i));
    el.opts.appendChild(b);
  });

  state.locked = false;
}

function lockOptions(v){
  [...el.opts.querySelectorAll("button")].forEach(x=> x.disabled = v);
}

/* ---------- FX ---------- */
function burst(x,y,good=true){
  const n = good ? 26 : 18;
  for(let i=0;i<n;i++){
    state.particles.push({
      x,y,
      vx:(Math.random()*2-1) * (good ? 2.6 : 2.1),
      vy:(Math.random()*-2.6) - (good ? 2.6 : 2.2),
      life: good ? 48 : 38,
      good,
      s: (Math.random()*1.8 + 1.2),
      r: Math.random()*Math.PI*2
    });
  }
}

/* ---------- Desktop scene logic ---------- */
function initDesktopScene(){
  state.desktopIcons = [];
  state.popups = [];

  // static icons
  const names = ["This PC","Browser","Docs","Recycle Bin","Settings","Security"];
  for(let i=0;i<8;i++){
    state.desktopIcons.push({
      x: 0.08 + (i%2)*0.12,
      y: 0.18 + Math.floor(i/2)*0.12,
      name: names[i % names.length],
      safe: true
    });
  }

  // warning icons/pins tied to checkpoints (red until solved)
  const warn = [
    {key:"accounts",  title:"Account risk"},
    {key:"lock",      title:"Auto-lock off"},
    {key:"updates",   title:"Updates paused"},
    {key:"firewall",  title:"Firewall off"},
    {key:"privacy",   title:"Mic permission"}
  ];
  warn.forEach((w,i)=>{
    state.desktopIcons.push({
      x: 0.56 + (i%2)*0.14,
      y: 0.22 + Math.floor(i/2)*0.14,
      name: w.title,
      key: w.key,
      safe: false
    });
  });

  // popups (these reduce as you solve checkpoints)
  state.popups.push({ key:"firewall",  title:"Windows Security", text:"Firewall is turned off for Public network.", age:0 });
  state.popups.push({ key:"updates",   title:"Update Service",   text:"Security updates are not installing.", age:0.8 });
  state.popups.push({ key:"privacy",   title:"Privacy Alert",    text:"Microphone access granted to an unknown app.", age:1.4 });
  state.popups.push({ key:"lock",      title:"Sign-in",          text:"Screen lock timeout is too long.", age:2.0 });
  state.popups.push({ key:"accounts",  title:"Accounts",         text:"Shared account detected. Use individual logins.", age:2.6 });
}

function cleanDesktopForCheckpoint(cpKey){
  // mark warning icon safe and fade corresponding popup
  for(const ic of state.desktopIcons){
    if(ic.key === cpKey) ic.safe = true;
  }
  state.popups = state.popups.filter(p => p.key !== cpKey);
}

/* ---------- Answer handling ---------- */
function answer(i){
  if(state.locked) return;
  state.locked = true;
  lockOptions(true);

  const ok = (i === state.currentQ.correct);
  const cp = CHECKPOINTS[state.idx];

  if(ok){
    el.fb.className = "fb show good";
    el.fbT.textContent = "Correct";
    el.fbP.textContent = state.currentQ.ok;

    state.solved[state.idx] = true;
    state.bridges = Math.max(state.bridges, state.idx+1);
    burst(pathPts[state.idx].x, pathPts[state.idx].y, true);

    // Mode 2: clean the desktop visual when solved
    cleanDesktopForCheckpoint(cp.key);

    const nextIdx = state.idx + 1;
    if(nextIdx < CHECKPOINTS.length){
      startMove(nextIdx);
    }else{
      state.idx++;
      loadQuestion();
    }
  }else{
    el.fb.className = "fb show bad";
    el.fbT.textContent = "Not correct";
    el.fbP.textContent = state.currentQ.bad;

    state.flash = 1.0;
    state.shake = 1.0;
    burst(pathPts[state.idx].x, pathPts[state.idx].y, false);
  }

  updateUI();
}

el.nextBtn.addEventListener("click", ()=>{
  if(!state.solved[state.idx]){
    loadQuestion();
    return;
  }
});

el.retryBtn.addEventListener("click", ()=>{
  if(el.retryBtn.textContent === "Play again"){
    reset();
    return;
  }
  loadQuestion();
});

el.resetBtn.addEventListener("click", reset);

/* ---------- Mode switch ---------- */
function setMode(m){
  state.mode = m;
  el.modeCorridor.classList.toggle("active", m==="corridor");
  el.modeDesktop.classList.toggle("active", m==="desktop");
  updateSceneSub();
}
el.modeCorridor.addEventListener("click", ()=> setMode("corridor"));
el.modeDesktop.addEventListener("click", ()=> setMode("desktop"));

/* ---------- Movement ---------- */
let pathPts = [];
const ctx = el.cv.getContext("2d", {alpha:false});
let W=0,H=0,dpr=1;

function resize(){
  const r = el.cv.getBoundingClientRect();
  dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(r.width*dpr);
  H = Math.floor(r.height*dpr);
  el.cv.width = W;
  el.cv.height = H;

  const padX = 76*dpr;
  const y = Math.floor(H*0.60);
  const span = (W - padX*2) / (CHECKPOINTS.length-1);
  pathPts = CHECKPOINTS.map((_,i)=> ({ x: Math.floor(padX + span*i), y }));
}
window.addEventListener("resize", resize);

function startMove(nextIdx){
  state.moving = true;
  state.moveT = 0;
  state.targetX = pathPts[nextIdx].x;
  state.targetY = pathPts[nextIdx].y + 18;
  state.nextIdx = nextIdx;
}
function ease(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

/* ---------- Corridor warning orbs ---------- */
function makeWarnOrbs(){
  const orbs = [];
  for(let i=0;i<14;i++){
    orbs.push({
      x: Math.random(),
      y: Math.random(),
      s: Math.random()*0.9+0.7,
      a: Math.random()*0.6+0.3,
      sp: Math.random()*0.25+0.08
    });
  }
  return orbs;
}

/* ---------- Draw helpers ---------- */
function roundRect(x,y,w,h,r){
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function glowCircle(x,y,rad,rgbaStr){
  const g = ctx.createRadialGradient(x,y,0,x,y,rad);
  g.addColorStop(0,rgbaStr);
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill();
}

/* ---------- Mode 1: Corridor scene ---------- */
function drawCorridorBackground(t){
  ctx.fillStyle = "#071024";
  ctx.fillRect(0,0,W,H);

  // soft blobs
  let g1 = ctx.createRadialGradient(W*0.18,H*0.16,0,W*0.18,H*0.16,W*0.62);
  g1.addColorStop(0,"rgba(74,163,255,.18)"); g1.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g1; ctx.fillRect(0,0,W,H);

  let g2 = ctx.createRadialGradient(W*0.84,H*0.72,0,W*0.84,H*0.72,W*0.70);
  g2.addColorStop(0,"rgba(61,220,151,.10)"); g2.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g2; ctx.fillRect(0,0,W,H);

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  const step = 40*dpr;
  for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();

  // "glass windows"
  for(let i=0;i<3;i++){
    const x = (W*(0.12 + i*0.28));
    const y = H*0.16;
    const w = W*0.18;
    const h = H*0.20;
    ctx.save();
    ctx.globalAlpha = 0.55;
    roundRect(x,y,w,h,18*dpr);
    ctx.fillStyle = "rgba(255,255,255,.05)"; ctx.fill();
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    ctx.lineWidth = 2*dpr; ctx.stroke();
    ctx.restore();
  }

  // floor
  const floorY = Math.floor(H*0.66);
  const fg = ctx.createLinearGradient(0,floorY,0,H);
  fg.addColorStop(0,"rgba(255,255,255,.06)");
  fg.addColorStop(1,"rgba(0,0,0,.35)");
  ctx.fillStyle = fg;
  ctx.fillRect(0,floorY,W,H-floorY);

  // CCTV camera + cone
  const camX = W - 80*dpr, camY = 70*dpr;
  ctx.save();
  roundRect(camX-34*dpr, camY-14*dpr, 54*dpr, 26*dpr, 10*dpr);
  ctx.fillStyle = "rgba(255,255,255,.06)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.16)"; ctx.lineWidth = 2*dpr; ctx.stroke();
  ctx.beginPath(); ctx.arc(camX+6*dpr, camY-1*dpr, 6*dpr, 0, Math.PI*2);
  ctx.fillStyle = "rgba(74,163,255,.75)"; ctx.fill();
  ctx.restore();

  // CCTV scan line (vertical sweeping)
  const scanW = 4*dpr;
  const scanX = (Math.sin(t*0.7) * 0.5 + 0.5) * (W - 120*dpr) + 60*dpr;
  ctx.save();
  const sg = ctx.createLinearGradient(scanX,0,scanX+scanW*12,0);
  sg.addColorStop(0,"rgba(74,163,255,0)");
  sg.addColorStop(0.45,"rgba(74,163,255,.22)");
  sg.addColorStop(0.55,"rgba(74,163,255,.22)");
  sg.addColorStop(1,"rgba(74,163,255,0)");
  ctx.fillStyle = sg;
  ctx.globalAlpha = 0.9;
  ctx.fillRect(scanX, 0, scanW*12, H);
  ctx.restore();

  // warning orbs drift (more visible when unsolved)
  const unsolved = CHECKPOINTS.length - state.solved.filter(Boolean).length;
  const alphaBoost = clamp(unsolved/5, 0.25, 1.0);
  for(const o of state.warnOrbs){
    o.y += o.sp * 0.0025;
    if(o.y > 1.12) o.y = -0.12;

    const x = o.x * W;
    const y = o.y * H;
    const r = 14*dpr * o.s;

    ctx.save();
    ctx.globalAlpha = o.a * alphaBoost * 0.9;
    glowCircle(x,y,r*2.6,"rgba(255,92,108,.20)");
    ctx.fillStyle = "rgba(255,92,108,.85)";
    ctx.beginPath(); ctx.arc(x,y,r*0.36,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // taskbar
  const tbH = 64*dpr, tbY = H - tbH - 18*dpr;
  ctx.save();
  roundRect(18*dpr,tbY,W-36*dpr,tbH,18*dpr);
  ctx.fillStyle = "rgba(0,0,0,.30)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();
  for(let i=0;i<4;i++){
    const ix = 36*dpr + i*52*dpr;
    const iy = tbY + 16*dpr;
    roundRect(ix,iy,36*dpr,36*dpr,12*dpr);
    ctx.fillStyle = "rgba(255,255,255,.05)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.12)"; ctx.stroke();
  }
  // right badges
  ctx.fillStyle = "rgba(255,255,255,.18)";
  ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
  ctx.textAlign = "right"; ctx.textBaseline = "middle";
  const badgeText = `Alerts: ${CHECKPOINTS.length - state.solved.filter(Boolean).length}`;
  ctx.fillText(badgeText, W - 36*dpr, tbY + tbH/2);
  ctx.restore();
}

function drawPathAndCheckpoints(){
  // base line
  ctx.save();
  ctx.lineWidth = 6*dpr;
  ctx.lineCap = "round";
  ctx.strokeStyle = "rgba(255,255,255,.12)";
  ctx.beginPath();
  ctx.moveTo(pathPts[0].x, pathPts[0].y);
  for(let i=1;i<pathPts.length;i++) ctx.lineTo(pathPts[i].x, pathPts[i].y);
  ctx.stroke();

  // built segments
  for(let i=0;i<state.bridges-1;i++){
    const a = pathPts[i], b = pathPts[i+1];
    const grad = ctx.createLinearGradient(a.x,a.y,b.x,b.y);
    grad.addColorStop(0,"rgba(61,220,151,.55)");
    grad.addColorStop(1,"rgba(74,163,255,.20)");
    ctx.strokeStyle = grad;
    ctx.lineWidth = 10*dpr;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    glowCircle(b.x,b.y,38*dpr,"rgba(61,220,151,.16)");
  }
  ctx.restore();

  // checkpoints
  for(let i=0;i<pathPts.length;i++){
    const p = pathPts[i];
    const solved = state.solved[i];
    const isCurrent = (i === state.idx);

    if(isCurrent) glowCircle(p.x,p.y,70*dpr,"rgba(74,163,255,.18)");

    ctx.save();
    ctx.lineWidth = 3*dpr;
    ctx.strokeStyle = solved ? "rgba(61,220,151,.85)" : (isCurrent ? "rgba(74,163,255,.85)" : "rgba(255,255,255,.25)");
    ctx.fillStyle = "rgba(0,0,0,.28)";
    ctx.beginPath(); ctx.arc(p.x,p.y,22*dpr,0,Math.PI*2); ctx.fill(); ctx.stroke();

    ctx.fillStyle = solved ? "rgba(61,220,151,.95)" : (isCurrent ? "rgba(74,163,255,.85)" : "rgba(255,255,255,.25)");
    ctx.beginPath(); ctx.arc(p.x,p.y,10*dpr,0,Math.PI*2); ctx.fill();

    // label plate
    const label = CHECKPOINTS[i].label;
    const plateW = Math.max(96*dpr, (label.length*7.2)*dpr);
    const plateH = 28*dpr;
    const px = p.x - plateW/2;
    const py = p.y - 56*dpr;
    roundRect(px,py,plateW,plateH,12*dpr);
    ctx.fillStyle = "rgba(0,0,0,.34)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.stroke();

    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(label, p.x, py + plateH/2);

    ctx.font = `${14*dpr}px system-ui, Segoe UI, Arial`;
    ctx.fillText(CHECKPOINTS[i].icon, p.x, p.y - 86*dpr);

    // warning sign above unsolved
    if(!solved){
      const wx = p.x + 28*dpr, wy = p.y - 22*dpr;
      ctx.globalAlpha = 0.9;
      glowCircle(wx,wy,26*dpr,"rgba(255,92,108,.14)");
      ctx.fillStyle = "rgba(255,92,108,.85)";
      ctx.beginPath(); ctx.arc(wx,wy,7*dpr,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,.88)";
      ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
      ctx.fillText("!", wx, wy+1*dpr);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }
}

function drawPlayer(t){
  const x = state.playerX;
  const y = state.playerY;
  const bob = Math.sin(t*8) * (state.moving ? 2*dpr : 1*dpr);

  ctx.save();
  ctx.translate(x, y + bob);

  // shadow
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "rgba(0,0,0,.55)";
  ctx.beginPath(); ctx.ellipse(0, 18*dpr, 22*dpr, 8*dpr, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // legs
  const step = Math.sin(t*10) * (state.moving ? 10*dpr : 2*dpr);
  ctx.strokeStyle = "rgba(234,240,255,.75)";
  ctx.lineWidth = 4*dpr;
  ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(-6*dpr, 10*dpr); ctx.lineTo(-10*dpr + step*0.06, 24*dpr); ctx.stroke();
  ctx.beginPath(); ctx.moveTo( 6*dpr, 10*dpr); ctx.lineTo( 10*dpr - step*0.06, 24*dpr); ctx.stroke();

  // body
  roundRect(-14*dpr, -10*dpr, 28*dpr, 26*dpr, 10*dpr);
  ctx.fillStyle = "rgba(74,163,255,.25)"; ctx.fill();
  ctx.strokeStyle = "rgba(74,163,255,.55)"; ctx.stroke();

  // toolbag
  roundRect(16*dpr, 0*dpr, 20*dpr, 16*dpr, 7*dpr);
  ctx.fillStyle = "rgba(255,204,102,.18)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,204,102,.55)"; ctx.stroke();

  // head
  ctx.beginPath(); ctx.arc(0, -18*dpr, 10*dpr, 0, Math.PI*2);
  ctx.fillStyle = "rgba(234,240,255,.85)"; ctx.fill();

  // visor
  ctx.globalAlpha = 0.7;
  ctx.fillStyle = "rgba(61,220,151,.65)";
  roundRect(-7*dpr, -21*dpr, 14*dpr, 6*dpr, 3*dpr);
  ctx.fill();
  ctx.globalAlpha = 1;

  // aura when moving
  if(state.moving){
    glowCircle(0,-2*dpr,40*dpr,"rgba(61,220,151,.12)");
  }

  ctx.restore();
}

function drawParticles(){
  for(const p of state.particles){
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life/60);
    ctx.translate(p.x, p.y);
    ctx.rotate(p.r);
    ctx.fillStyle = p.good ? "rgba(61,220,151,.9)" : "rgba(255,92,108,.9)";
    roundRect(-2*dpr*p.s, -2*dpr*p.s, 4*dpr*p.s, 4*dpr*p.s, 1.2*dpr);
    ctx.fill();
    ctx.restore();
  }
}

/* ---------- Mode 2: Desktop scene ---------- */
function drawDesktopBackground(){
  // base wallpaper
  ctx.fillStyle = "#06102a";
  ctx.fillRect(0,0,W,H);

  const w1 = ctx.createRadialGradient(W*0.25,H*0.18,0,W*0.25,H*0.18,W*0.65);
  w1.addColorStop(0,"rgba(74,163,255,.22)"); w1.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = w1; ctx.fillRect(0,0,W,H);

  const w2 = ctx.createRadialGradient(W*0.78,H*0.76,0,W*0.78,H*0.76,W*0.70);
  w2.addColorStop(0,"rgba(61,220,151,.12)"); w2.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = w2; ctx.fillRect(0,0,W,H);

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.strokeStyle = "rgba(255,255,255,.18)";
  const step = 44*dpr;
  for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();

  // top bar (fake window title)
  ctx.save();
  const h = 46*dpr;
  roundRect(18*dpr, 14*dpr, W-36*dpr, h, 16*dpr);
  ctx.fillStyle = "rgba(0,0,0,.26)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();
  ctx.fillStyle = "rgba(234,240,255,.88)";
  ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
  ctx.textAlign = "left"; ctx.textBaseline = "middle";
  ctx.fillText("Desktop ‚Äî Office PC (Rescue Mode)", 36*dpr, 14*dpr + h/2);
  ctx.restore();

  // taskbar
  const tbH = 64*dpr, tbY = H - tbH - 18*dpr;
  ctx.save();
  roundRect(18*dpr,tbY,W-36*dpr,tbH,18*dpr);
  ctx.fillStyle = "rgba(0,0,0,.34)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();

  // icons left
  for(let i=0;i<5;i++){
    const ix = 36*dpr + i*52*dpr;
    const iy = tbY + 16*dpr;
    roundRect(ix,iy,36*dpr,36*dpr,12*dpr);
    ctx.fillStyle = "rgba(255,255,255,.05)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.12)"; ctx.stroke();
  }

  // "clock"
  ctx.fillStyle = "rgba(255,255,255,.18)";
  ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
  ctx.textAlign = "right"; ctx.textBaseline = "middle";
  ctx.fillText("Office Wi-Fi ‚Ä¢ SecOps", W-36*dpr, tbY + tbH/2);
  ctx.restore();
}

function drawDesktopIcons(t){
  // icons
  for(const ic of state.desktopIcons){
    const x = ic.x * W;
    const y = ic.y * H;

    // glow for unsafe icons
    if(!ic.safe){
      glowCircle(x+18*dpr, y+18*dpr, 48*dpr, "rgba(255,92,108,.12)");
    }

    // icon tile
    ctx.save();
    roundRect(x, y, 44*dpr, 44*dpr, 14*dpr);
    ctx.fillStyle = "rgba(0,0,0,.22)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();

    // inner symbol
    ctx.fillStyle = ic.safe ? "rgba(61,220,151,.82)" : "rgba(255,92,108,.85)";
    ctx.beginPath(); ctx.arc(x+22*dpr, y+22*dpr, 8*dpr, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,.88)";
    ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(ic.safe ? "‚úì" : "!", x+22*dpr, y+22*dpr+1*dpr);

    // label
    ctx.fillStyle = "rgba(234,240,255,.86)";
    ctx.font = `${11*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "left"; ctx.textBaseline = "top";
    ctx.fillText(ic.name, x, y+50*dpr);

    ctx.restore();
  }

  // subtle ‚Äúsecurity sweep‚Äù scan line across desktop (Mode 2)
  const scan = (Math.sin(t*0.55)*0.5+0.5) * (H*0.72) + H*0.12;
  ctx.save();
  ctx.globalAlpha = 0.6;
  const sg = ctx.createLinearGradient(0,scan-20*dpr,0,scan+20*dpr);
  sg.addColorStop(0,"rgba(74,163,255,0)");
  sg.addColorStop(0.5,"rgba(74,163,255,.18)");
  sg.addColorStop(1,"rgba(74,163,255,0)");
  ctx.fillStyle = sg;
  ctx.fillRect(0, scan-20*dpr, W, 40*dpr);
  ctx.restore();
}

function drawPopups(t){
  // popups stack top-right
  const baseX = W - 18*dpr;
  let y = 78*dpr;

  for(const p of state.popups){
    const w = Math.min(W*0.46, 420*dpr);
    const h = 74*dpr;
    const x = baseX - w;

    // slight float
    const float = Math.sin((t + p.age)*1.6) * 2*dpr;

    ctx.save();
    glowCircle(x + w - 36*dpr, y + 16*dpr, 46*dpr, "rgba(255,204,102,.10)");
    roundRect(x, y + float, w, h, 18*dpr);
    ctx.fillStyle = "rgba(0,0,0,.28)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();

    // left indicator
    ctx.fillStyle = "rgba(255,92,108,.85)";
    roundRect(x+10*dpr, y+float+10*dpr, 10*dpr, h-20*dpr, 8*dpr);
    ctx.fill();

    // title + text
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "left"; ctx.textBaseline = "top";
    ctx.fillText(p.title, x+28*dpr, y+float+12*dpr);

    ctx.fillStyle = "rgba(169,182,214,.92)";
    ctx.font = `${11*dpr}px system-ui, Segoe UI, Arial`;
    ctx.fillText(p.text, x+28*dpr, y+float+34*dpr);

    // small button
    roundRect(x+w-98*dpr, y+float+22*dpr, 82*dpr, 28*dpr, 12*dpr);
    ctx.fillStyle = "rgba(74,163,255,.14)"; ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.stroke();
    ctx.fillStyle = "rgba(234,240,255,.9)";
    ctx.font = `${11*dpr}px system-ui, Segoe UI, Arial`;
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText("Fix", x+w-57*dpr, y+float+36*dpr);

    ctx.restore();

    y += h + 12*dpr;
    if(y > H*0.58) break;
  }
}

function drawDesktopProgressBadge(){
  const done = state.solved.filter(Boolean).length;
  const w = 240*dpr, h = 58*dpr;
  const x = 18*dpr, y = H - h - 96*dpr;

  ctx.save();
  glowCircle(x+50*dpr, y+10*dpr, 60*dpr, "rgba(61,220,151,.10)");
  roundRect(x,y,w,h,18*dpr);
  ctx.fillStyle = "rgba(0,0,0,.26)"; ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2*dpr; ctx.stroke();

  ctx.fillStyle = "rgba(234,240,255,.92)";
  ctx.font = `${12*dpr}px system-ui, Segoe UI, Arial`;
  ctx.textAlign = "left"; ctx.textBaseline = "top";
  ctx.fillText("Security Cleanup", x+16*dpr, y+10*dpr);

  ctx.fillStyle = "rgba(169,182,214,.92)";
  ctx.font = `${11*dpr}px system-ui, Segoe UI, Arial`;
  ctx.fillText(`${done}/5 issues fixed`, x+16*dpr, y+30*dpr);

  // mini bar
  const bx = x + 120*dpr, by = y + 34*dpr, bw = 102*dpr, bh = 10*dpr;
  roundRect(bx,by,bw,bh,999*dpr);
  ctx.fillStyle = "rgba(255,255,255,.08)"; ctx.fill();
  roundRect(bx,by,bw*(done/5),bh,999*dpr);
  ctx.fillStyle = "rgba(61,220,151,.75)"; ctx.fill();

  ctx.restore();
}

/* ---------- Keyboard support ---------- */
document.addEventListener("keydown", (e)=>{
  const n = parseInt(e.key,10);
  if(n>=1 && n<=4){
    const btn = el.opts.querySelectorAll("button")[n-1];
    if(btn && !btn.disabled) btn.click();
  }
});

/* ---------- Loop ---------- */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last = now;
  const t = now/1000;

  // movement
  if(state.moving){
    state.moveT += dt;
    const k = clamp(state.moveT / 0.85, 0, 1);
    const e = ease(k);

    const sx = pathPts[state.idx].x;
    const sy = pathPts[state.idx].y + 18;

    state.playerX = sx + (state.targetX - sx) * e;
    state.playerY = sy + (state.targetY - sy) * e;

    if(k >= 1){
      state.moving = false;
      state.idx = state.nextIdx;
      loadQuestion();
      updateUI();
    }
  }

  // flash + shake decay
  state.flash = Math.max(0, state.flash - dt*2.2);
  state.shake = Math.max(0, state.shake - dt*2.6);

  // particles
  for(const p of state.particles){
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.vy += 0.22 * 60 * dt;
    p.life -= 1;
    p.r += 0.06;
  }
  state.particles = state.particles.filter(p=> p.life > 0);

  // render
  ctx.save();
  if(state.shake > 0){
    const mag = 6*dpr*state.shake;
    ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
  }

  if(state.mode === "corridor"){
    drawCorridorBackground(t);
    drawPathAndCheckpoints();
    drawParticles();
    drawPlayer(t);
  }else{
    drawDesktopBackground();
    drawDesktopIcons(t);
    drawPopups(t);
    drawDesktopProgressBadge();

    // still show small ‚Äúcheckpoint path‚Äù at bottom to feel like a game
    ctx.save();
    ctx.globalAlpha = 0.78;
    drawPathAndCheckpoints();
    ctx.globalAlpha = 1;
    drawParticles();
    drawPlayer(t);
    ctx.restore();
  }

  // alert flash overlay
  if(state.flash > 0){
    ctx.save();
    ctx.globalAlpha = 0.22 * state.flash;
    ctx.fillStyle = "rgba(255,92,108,.9)";
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  ctx.restore();

  requestAnimationFrame(tick);
}

/* ---------- Start ---------- */
resize();
updateSceneSub();
reset();
requestAnimationFrame(tick);
</script>
</body>
</html>
